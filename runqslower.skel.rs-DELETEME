// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
//
// THIS FILE IS AUTOGENERATED BY CARGO-LIBBPF-GEN!

#![allow(clippy::transmute_ptr_to_ref)]

use libbpf_rs::libbpf_sys;

const DATA: &[u8] = include_bytes!("/home/daniel/dev/libbpf-rs/target/bpf/runqslower.bpf.o");

fn build_skel_config() -> libbpf_rs::Result<libbpf_rs::skeleton::ObjectSkeletonConfig<'static>> {
    let mut builder = libbpf_rs::skeleton::ObjectSkeletonConfigBuilder::new(DATA);
    builder
        .name("runqslower_bpf")
        .map("start", false)
        .map("events", false)
        .map("runqslow.rodata", true)
        .prog("handle__sched_wakeup")
        .prog("handle__sched_wakeup_new")
        .prog("handle__sched_switch");

    builder.build()
}

#[derive(Default)]
pub struct RunqslowerSkelBuilder {
    pub obj_builder: libbpf_rs::ObjectBuilder,
}

impl RunqslowerSkelBuilder {
    pub fn open(&mut self) -> libbpf_rs::Result<OpenRunqslowerSkel> {
        let mut skel_config = build_skel_config()?;
        let open_opts = self.obj_builder.opts(std::ptr::null());

        let ret = unsafe { libbpf_sys::bpf_object__open_skeleton(skel_config.get(), &open_opts) };
        if ret != 0 {
            return Err(libbpf_rs::Error::System(-ret));
        }

        let obj = unsafe { libbpf_rs::OpenObject::from_ptr(skel_config.object_ptr()) };

        Ok(OpenRunqslowerSkel { obj, skel_config })
    }
}

pub struct OpenRunqslowerMaps<'a> {
    inner: &'a mut libbpf_rs::OpenObject,
}

impl<'a> OpenRunqslowerMaps<'a> {
    pub fn start(&mut self) -> &mut libbpf_rs::OpenMap {
        self.inner.map_unwrap("start")
    }

    pub fn events(&mut self) -> &mut libbpf_rs::OpenMap {
        self.inner.map_unwrap("events")
    }
}

pub struct OpenRunqslowerProgs<'a> {
    inner: &'a mut libbpf_rs::OpenObject,
}

impl<'a> OpenRunqslowerProgs<'a> {
    pub fn handle__sched_wakeup(&mut self) -> &mut libbpf_rs::OpenProgram {
        self.inner.prog_unwrap("handle__sched_wakeup")
    }

    pub fn handle__sched_wakeup_new(&mut self) -> &mut libbpf_rs::OpenProgram {
        self.inner.prog_unwrap("handle__sched_wakeup_new")
    }

    pub fn handle__sched_switch(&mut self) -> &mut libbpf_rs::OpenProgram {
        self.inner.prog_unwrap("handle__sched_switch")
    }
}

pub mod runqslower_rodata_types {
    #[derive(Debug, Copy, Clone)]
    #[repr(C)]
    pub struct rodata {
        pub min_us: u64,
        pub targ_pid: i32,
        pub targ_tgid: i32,
    }
}

pub struct OpenRunqslowerSkel<'a> {
    pub obj: libbpf_rs::OpenObject,
    skel_config: libbpf_rs::skeleton::ObjectSkeletonConfig<'a>,
}

impl<'a> OpenRunqslowerSkel<'a> {
    pub fn load(mut self) -> libbpf_rs::Result<RunqslowerSkel<'a>> {
        let ret = unsafe { libbpf_sys::bpf_object__load_skeleton(self.skel_config.get()) };
        if ret != 0 {
            return Err(libbpf_rs::Error::System(-ret));
        }

        let obj = unsafe { libbpf_rs::Object::from_ptr(self.obj.take_ptr()) };

        Ok(RunqslowerSkel {
            obj,
            skel_config: self.skel_config,
            links: RunqslowerLinks::default(),
        })
    }

    pub fn progs(&mut self) -> OpenRunqslowerProgs {
        OpenRunqslowerProgs {
            inner: &mut self.obj,
        }
    }

    pub fn maps(&mut self) -> OpenRunqslowerMaps {
        OpenRunqslowerMaps {
            inner: &mut self.obj,
        }
    }

    pub fn rodata(&mut self) -> &'a mut runqslower_rodata_types::rodata {
        unsafe {
            std::mem::transmute::<*mut std::ffi::c_void, &'a mut runqslower_rodata_types::rodata>(
                self.skel_config.map_mmap_ptr(2).unwrap(),
            )
        }
    }
}

pub struct RunqslowerMaps<'a> {
    inner: &'a mut libbpf_rs::Object,
}

impl<'a> RunqslowerMaps<'a> {
    pub fn start(&mut self) -> &mut libbpf_rs::Map {
        self.inner.map_unwrap("start")
    }

    pub fn events(&mut self) -> &mut libbpf_rs::Map {
        self.inner.map_unwrap("events")
    }
}

pub struct RunqslowerProgs<'a> {
    inner: &'a mut libbpf_rs::Object,
}

impl<'a> RunqslowerProgs<'a> {
    pub fn handle__sched_wakeup(&mut self) -> &mut libbpf_rs::Program {
        self.inner.prog_unwrap("handle__sched_wakeup")
    }

    pub fn handle__sched_wakeup_new(&mut self) -> &mut libbpf_rs::Program {
        self.inner.prog_unwrap("handle__sched_wakeup_new")
    }

    pub fn handle__sched_switch(&mut self) -> &mut libbpf_rs::Program {
        self.inner.prog_unwrap("handle__sched_switch")
    }
}

#[derive(Default)]
pub struct RunqslowerLinks {
    pub handle__sched_wakeup: Option<libbpf_rs::Link>,
    pub handle__sched_wakeup_new: Option<libbpf_rs::Link>,
    pub handle__sched_switch: Option<libbpf_rs::Link>,
}

pub struct RunqslowerSkel<'a> {
    pub obj: libbpf_rs::Object,
    skel_config: libbpf_rs::skeleton::ObjectSkeletonConfig<'a>,
    pub links: RunqslowerLinks,
}

impl<'a> RunqslowerSkel<'a> {
    pub fn progs(&mut self) -> RunqslowerProgs {
        RunqslowerProgs {
            inner: &mut self.obj,
        }
    }

    pub fn maps(&mut self) -> RunqslowerMaps {
        RunqslowerMaps {
            inner: &mut self.obj,
        }
    }

    pub fn rodata(&mut self) -> &'a runqslower_rodata_types::rodata {
        unsafe {
            std::mem::transmute::<*mut std::ffi::c_void, &'a runqslower_rodata_types::rodata>(
                self.skel_config.map_mmap_ptr(2).unwrap(),
            )
        }
    }

    pub fn attach(&mut self) -> libbpf_rs::Result<()> {
        let ret = unsafe { libbpf_sys::bpf_object__attach_skeleton(self.skel_config.get()) };
        if ret != 0 {
            return Err(libbpf_rs::Error::System(-ret));
        }

        self.links = RunqslowerLinks {
            handle__sched_wakeup: (|| {
                let ptr = self.skel_config.prog_link_ptr(0)?;
                if ptr.is_null() {
                    Ok(None)
                } else {
                    Ok(Some(unsafe { libbpf_rs::Link::from_ptr(ptr) }))
                }
            })()?,
            handle__sched_wakeup_new: (|| {
                let ptr = self.skel_config.prog_link_ptr(1)?;
                if ptr.is_null() {
                    Ok(None)
                } else {
                    Ok(Some(unsafe { libbpf_rs::Link::from_ptr(ptr) }))
                }
            })()?,
            handle__sched_switch: (|| {
                let ptr = self.skel_config.prog_link_ptr(2)?;
                if ptr.is_null() {
                    Ok(None)
                } else {
                    Ok(Some(unsafe { libbpf_rs::Link::from_ptr(ptr) }))
                }
            })()?,
        };

        Ok(())
    }
}
